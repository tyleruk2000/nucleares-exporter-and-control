<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Nucleares Metrics Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 0;
        background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000 100%);
        color: #e5e7eb;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 16px 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(148, 163, 184, 0.35);
        backdrop-filter: blur(16px);
        background: rgba(15, 23, 42, 0.9);
        position: sticky;
        top: 0;
        z-index: 10;
      }
      header h1 {
        margin: 0;
        font-size: 1.2rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #a5b4fc;
      }
      header .sub {
        font-size: 0.8rem;
        color: #9ca3af;
        margin-top: 4px;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 0.85rem;
      }
      .controls label {
        color: #9ca3af;
      }
      .controls input {
        width: 72px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(15, 23, 42, 0.9);
        color: #e5e7eb;
        font-size: 0.8rem;
      }
      .controls button {
        padding: 6px 12px;
        border-radius: 999px;
        border: none;
        background: linear-gradient(90deg, #4f46e5, #6366f1);
        color: white;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
      }
      .controls button.secondary {
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.6);
      }
      .controls button:disabled {
        opacity: 0.5;
        cursor: default;
      }
      main {
        padding: 16px 24px 32px;
      }
      .meta {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        font-size: 0.8rem;
        color: #9ca3af;
        margin-bottom: 16px;
      }
      .meta span strong {
        color: #e5e7eb;
      }
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 14px;
      }
      .metric-card {
        background: rgba(15, 23, 42, 0.92);
        border-radius: 12px;
        padding: 10px 12px 10px;
        border: 1px solid rgba(31, 41, 55, 0.9);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .metric-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 8px;
      }
      .metric-name {
        font-size: 0.82rem;
        font-weight: 600;
        color: #e5e7eb;
        word-break: break-word;
      }
      .metric-prom {
        font-size: 0.7rem;
        color: #6b7280;
        word-break: break-all;
      }
      .metric-value {
        font-size: 0.95rem;
        font-weight: 600;
        color: #a5b4fc;
      }
      .metric-type {
        font-size: 0.7rem;
        color: #9ca3af;
      }
      .metric-chart {
        margin-top: 4px;
      }
      .metric-chart canvas {
        width: 100%;
        height: 40px;
        display: block;
      }
      .metric-controls {
        margin-top: 6px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .metric-controls-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.78rem;
      }
      .metric-controls-row input[type='text'] {
        flex: 1;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(15, 23, 42, 0.9);
        color: #e5e7eb;
        font-size: 0.78rem;
      }
      .metric-controls-row button {
        padding: 4px 10px;
        border-radius: 999px;
        border: none;
        background: linear-gradient(90deg, #4f46e5, #6366f1);
        color: white;
        font-size: 0.76rem;
        font-weight: 600;
        cursor: pointer;
      }
      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
      }
      .toggle input {
        display: none;
      }
      .toggle-pill {
        width: 32px;
        height: 18px;
        border-radius: 999px;
        background: #374151;
        position: relative;
        transition: background 120ms ease-out;
      }
      .toggle-pill-thumb {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: white;
        transition: transform 120ms ease-out;
      }
      .toggle input:checked + .toggle-pill .toggle-pill-thumb {
        transform: translateX(14px);
      }
      .toggle input:checked + .toggle-pill {
        background: #22c55e;
      }
      .metric-controls-status {
        font-size: 0.7rem;
        color: #9ca3af;
      }
      .empty {
        font-size: 0.9rem;
        color: #9ca3af;
        margin-top: 24px;
      }
      .category-section {
        margin-bottom: 24px;
      }
      .category-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        background: rgba(15, 23, 42, 0.95);
        border-radius: 8px;
        border: 1px solid rgba(31, 41, 55, 0.9);
        cursor: pointer;
        user-select: none;
        margin-bottom: 10px;
        transition: background 0.2s;
      }
      .category-header:hover {
        background: rgba(15, 23, 42, 1);
      }
      .category-header h3 {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 600;
        color: #a5b4fc;
        flex: 1;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .category-toggle {
        font-size: 0.7rem;
        color: #6b7280;
        font-weight: 500;
      }
      .category-count {
        font-size: 0.75rem;
        color: #9ca3af;
        background: rgba(31, 41, 55, 0.8);
        padding: 2px 8px;
        border-radius: 999px;
      }
      .category-content {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 14px;
      }
      .category-content.collapsed {
        display: none;
      }
      .expand-all-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
        font-size: 0.8rem;
      }
      .expand-all-controls button {
        padding: 6px 12px;
        border-radius: 999px;
        border: none;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.6);
        color: #e5e7eb;
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
      }
      .expand-all-controls button:hover {
        background: rgba(15, 23, 42, 1);
      }
      @media (max-width: 640px) {
        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }
        .controls {
          width: 100%;
          justify-content: space-between;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div>
        <h1>Nucleares Metrics</h1>
        <div class="sub">Live view of exported Nucleares variables (from /metrics)</div>
      </div>
      <div class="controls">
        <label for="intervalInput">Refresh (s)</label>
        <input id="intervalInput" type="number" min="5" max="600" step="5" value="30" />
        <button id="refreshNowBtn">Refresh now</button>
        <button id="toggleAutoBtn" class="secondary">Pause auto</button>
      </div>
    </header>
    <main>
      <div class="meta">
        <span><strong>Status:</strong> <span id="statusText">Connecting…</span></span>
        <span><strong>Last update:</strong> <span id="lastUpdateText">–</span></span>
        <span><strong>Metrics:</strong> <span id="metricCountText">–</span></span>
      </div>
      <div class="expand-all-controls">
        <button id="expandAllBtn">Expand all</button>
        <button id="collapseAllBtn">Collapse all</button>
      </div>
      <div id="metricsContainer"></div>
      <div id="emptyState" class="empty" style="display: none">
        No Nucleares metrics found yet. Ensure the exporter is running and that `/metrics` is reachable.
      </div>
      <h2 style="margin-top: 28px; font-size: 0.95rem; color: #9ca3af; font-weight: 500">
        Control variables (POST)
      </h2>
      <div id="postControlsContainer" class="metrics-grid" style="margin-top: 8px"></div>
      <div id="postEmptyState" class="empty" style="display: none">
        No POST variables discovered yet. They are parsed from the Nucleares web page on server startup.
      </div>
    </main>

    <script>
      const metricsContainer = document.getElementById('metricsContainer');
      const emptyState = document.getElementById('emptyState');
      const statusText = document.getElementById('statusText');
      const lastUpdateText = document.getElementById('lastUpdateText');
      const metricCountText = document.getElementById('metricCountText');
      const intervalInput = document.getElementById('intervalInput');
      const refreshNowBtn = document.getElementById('refreshNowBtn');
      const toggleAutoBtn = document.getElementById('toggleAutoBtn');
      const postControlsContainer = document.getElementById('postControlsContainer');
      const postEmptyState = document.getElementById('postEmptyState');
      const expandAllBtn = document.getElementById('expandAllBtn');
      const collapseAllBtn = document.getElementById('collapseAllBtn');

      let refreshIntervalMs = 30000;
      let intervalId = null;

      // key: variable name (or metric name as fallback) -> { history: [{t, v}], dom: { ... } }
      const metricState = {};
      const MAX_POINTS = 60;
      let postVariables = [];

      function humanizeVariableName(name) {
        return name.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, (c) => c.toUpperCase());
      }

      function getCategory(variableName) {
        if (!variableName) return 'Other';
        const parts = variableName.split('_');
        if (parts.length > 0 && parts[0]) {
          return parts[0];
        }
        return 'Other';
      }

      function getCategoryDisplayName(category) {
        return category.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, (c) => c.toUpperCase());
      }

      function classifyValue(rawValue) {
        const num = Number(rawValue);
        if (!Number.isNaN(num)) {
          return { type: 'number', display: rawValue };
        }
        return { type: 'string', display: rawValue };
      }

      function getStem(name) {
        const parts = name.split('_');
        if (parts.length <= 1) return name;
        return parts.slice(0, parts.length - 1).join('_');
      }

      function drawSparkline(canvas, history) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);

        if (!history || history.length === 0) {
          ctx.strokeStyle = '#4b5563';
          ctx.beginPath();
          ctx.moveTo(0, h / 2);
          ctx.lineTo(w, h / 2);
          ctx.stroke();
          return;
        }

        // If we only have a single point, duplicate it so we can render a proper line immediately.
        const points = history.length === 1 ? [history[0], history[0]] : history;

        const values = points.map((p) => p.v);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const span = max - min || 1;

        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        points.forEach((point, i) => {
          const x = (i / (points.length - 1 || 1)) * (w - 2) + 1;
          const norm = (point.v - min) / span;
          const y = h - norm * (h - 4) - 2;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      function ensureMetricCard(key, metric, controlVarsForMetric) {
        // Reuse existing DOM if we already know this metric
        if (metricState[key] && metricState[key].dom) {
          return metricState[key].dom;
        }

        const card = document.createElement('div');
        card.className = 'metric-card';

        const header = document.createElement('div');
        header.className = 'metric-header';

        const nameEl = document.createElement('div');
        nameEl.className = 'metric-name';
        nameEl.textContent = humanizeVariableName(metric.variable || metric.name);

        const valueEl = document.createElement('div');
        valueEl.className = 'metric-value';
        valueEl.textContent = metric.value;

        header.appendChild(nameEl);
        header.appendChild(valueEl);

        const promEl = document.createElement('div');
        promEl.className = 'metric-prom';
        promEl.textContent = metric.name + (metric.variable ? ` {variable="${metric.variable}"}` : '');

        const typeEl = document.createElement('div');
        typeEl.className = 'metric-type';
        typeEl.textContent = metric.typeLabel;

        const chartWrapper = document.createElement('div');
        chartWrapper.className = 'metric-chart';
        const canvas = document.createElement('canvas');
        canvas.width = 260;
        canvas.height = 40;
        chartWrapper.appendChild(canvas);

        card.appendChild(header);
        card.appendChild(promEl);
        card.appendChild(typeEl);
        card.appendChild(chartWrapper);

        if (controlVarsForMetric && controlVarsForMetric.length) {
          const controls = document.createElement('div');
          controls.className = 'metric-controls';

          controlVarsForMetric.forEach((controlVar) => {
            const row = document.createElement('div');
            row.className = 'metric-controls-row';

            const label = document.createElement('div');
            label.textContent = controlVar.split('_').slice(-1)[0].toLowerCase();
            label.style.textTransform = 'capitalize';

            // Heuristic: POST variables ending in SWITCH/STOP/TRIP/RESET/OPEN/CLOSE/EMERGENCY are treated as booleans.
            // MODE and ORDERED remain text/number respectively.
            // Match whole words/suffixes, not substrings (e.g., OPENING should not match OPEN)
            const isBoolLike = /_(SWITCH|STOP|TRIP|RESET|OPEN|CLOSE|EMERGENCY)$|^(SWITCH|STOP|TRIP|RESET|OPEN|CLOSE|EMERGENCY)_/i.test(controlVar);

            const statusEl = document.createElement('div');
            statusEl.className = 'metric-controls-status';

            async function send(value) {
              statusEl.textContent = 'Sending…';
              try {
                const res = await fetch('/api/post-variable', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ variable: controlVar, value }),
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok || data.ok === false) {
                  throw new Error(data.error || `HTTP ${res.status}`);
                }
                statusEl.textContent = 'OK';
              } catch (err) {
                console.error('Failed to set POST variable', err);
                statusEl.textContent = 'Error: ' + err.message;
              }
            }

            if (isBoolLike) {
              const toggleLabel = document.createElement('label');
              toggleLabel.className = 'toggle';

              const checkbox = document.createElement('input');
              checkbox.type = 'checkbox';

              const pill = document.createElement('span');
              pill.className = 'toggle-pill';
              const thumb = document.createElement('span');
              thumb.className = 'toggle-pill-thumb';
              pill.appendChild(thumb);

              const text = document.createElement('span');
              text.textContent = 'Off';
              text.style.fontSize = '0.78rem';
              text.style.color = '#d1d5db';

              checkbox.addEventListener('change', () => {
                text.textContent = checkbox.checked ? 'On' : 'Off';
              });

              toggleLabel.appendChild(checkbox);
              toggleLabel.appendChild(pill);
              toggleLabel.appendChild(text);

              const btn = document.createElement('button');
              btn.textContent = 'Send';

              btn.addEventListener('click', () => {
                const value = checkbox.checked ? 'true' : 'false';
                send(value);
              });

              row.appendChild(label);
              row.appendChild(toggleLabel);
              row.appendChild(btn);
              controls.appendChild(row);
              controls.appendChild(statusEl);
            } else {
              const input = document.createElement('input');
              input.type = 'text';
              input.placeholder = 'Value';

              const btn = document.createElement('button');
              btn.textContent = 'Send';

              btn.addEventListener('click', () => {
                const value = input.value;
                if (!value.length) {
                  statusEl.textContent = 'Enter a value.';
                  return;
                }
                send(value);
              });

              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  const value = input.value;
                  if (!value.length) {
                    statusEl.textContent = 'Enter a value.';
                    return;
                  }
                  send(value);
                }
              });

              row.appendChild(label);
              row.appendChild(input);
              row.appendChild(btn);
              controls.appendChild(row);
              controls.appendChild(statusEl);
            }
          });

          card.appendChild(controls);
        }

        // Don't append here - will be appended to category content in fetchAndRenderMetrics

        if (!metricState[key]) metricState[key] = { history: [] };
        metricState[key].dom = { card, nameEl, valueEl, typeEl, canvas };
        return metricState[key].dom;
      }

      function updateMetricHistory(key, numericValue) {
        if (!metricState[key]) metricState[key] = { history: [] };
        const history = metricState[key].history;
        history.push({ t: Date.now(), v: numericValue });
        if (history.length > MAX_POINTS) history.splice(0, history.length - MAX_POINTS);
      }

      function parsePrometheus(text) {
        const lines = text.split('\n');
        const help = {};
        const type = {};
        const metrics = [];

        for (const line of lines) {
          if (!line || line.startsWith('# EOF')) continue;
          if (line.startsWith('# HELP')) {
            const parts = line.split(/\s+/, 4);
            if (parts.length >= 3) help[parts[2]] = parts.slice(3).join(' ');
            continue;
          }
          if (line.startsWith('# TYPE')) {
            const parts = line.split(/\s+/, 4);
            if (parts.length >= 3) type[parts[2]] = parts[3] || 'gauge';
            continue;
          }

          if (!line.startsWith('nucleares_')) continue;

          const match = /^([a-zA-Z_:][\w:]*)(\{[^}]*\})?\s+([^\s]+)\s*$/.exec(line);
          if (!match) continue;

          const name = match[1];
          const labelsStr = match[2];
          const value = match[3];

          let variable = null;
          if (labelsStr) {
            const varMatch = /variable="([^"]*)"/.exec(labelsStr);
            if (varMatch) variable = varMatch[1];
          }

          metrics.push({
            key: variable || name,
            name,
            variable,
            value,
            help: help[name],
            promType: type[name] || 'gauge',
          });
        }

        return metrics;
      }

      function createCategorySection(category, metrics) {
        const section = document.createElement('div');
        section.className = 'category-section';
        section.dataset.category = category;

        const header = document.createElement('div');
        header.className = 'category-header';

        const title = document.createElement('h3');
        title.textContent = getCategoryDisplayName(category);

        const count = document.createElement('span');
        count.className = 'category-count';
        count.textContent = metrics.length;

        const toggle = document.createElement('span');
        toggle.className = 'category-toggle';
        toggle.textContent = '▼';

        header.appendChild(title);
        header.appendChild(count);
        header.appendChild(toggle);

        const content = document.createElement('div');
        content.className = 'category-content';

        header.addEventListener('click', () => {
          const isCollapsed = content.classList.contains('collapsed');
          content.classList.toggle('collapsed');
          toggle.textContent = isCollapsed ? '▼' : '▶';
        });

        section.appendChild(header);
        section.appendChild(content);

        return { section, content };
      }

      async function fetchAndRenderMetrics() {
        try {
          statusText.textContent = 'Refreshing…';
          const res = await fetch('/metrics');
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const text = await res.text();
          const metrics = parsePrometheus(text);

          metrics.sort((a, b) => a.key.localeCompare(b.key));

          metricsContainer.innerHTML = '';

          if (!metrics.length) {
            emptyState.style.display = 'block';
            metricCountText.textContent = '0';
            return;
          }

          emptyState.style.display = 'none';
          metricCountText.textContent = String(metrics.length);

          // Group metrics by category
          const metricsByCategory = {};
          for (const m of metrics) {
            const variableName = m.variable || m.name.replace(/^nucleares_/, '').toUpperCase();
            const category = getCategory(variableName);
            if (!metricsByCategory[category]) {
              metricsByCategory[category] = [];
            }
            metricsByCategory[category].push(m);
          }

          // Sort categories
          const sortedCategories = Object.keys(metricsByCategory).sort();

          // Render each category
          for (const category of sortedCategories) {
            const categoryMetrics = metricsByCategory[category];
            const { section, content } = createCategorySection(category, categoryMetrics);

            for (const m of categoryMetrics) {
              const classification = classifyValue(m.value);
              m.typeLabel = m.promType;
              m.classification = classification;

              const numeric = Number(m.value);
              if (!Number.isNaN(numeric)) {
                updateMetricHistory(m.key, numeric);
              }

              const variableName = m.variable || m.name.replace(/^nucleares_/, '').toUpperCase();
              const stem = getStem(variableName);
              const controlVarsForMetric = postVariables.filter((pv) => getStem(pv) === stem);

              const dom = ensureMetricCard(m.key, m, controlVarsForMetric);
              dom.valueEl.textContent = classification.display;
              dom.typeEl.textContent = m.typeLabel;
              drawSparkline(dom.canvas, metricState[m.key]?.history || []);

              // Move the card to the category content
              content.appendChild(dom.card);
            }

            metricsContainer.appendChild(section);
          }

          const now = new Date();
          lastUpdateText.textContent = now.toLocaleTimeString();
          statusText.textContent = 'Live';
        } catch (err) {
          console.error('Failed to load /metrics', err);
          statusText.textContent = 'Offline';
        }
      }

      function startAutoRefresh() {
        if (intervalId) clearInterval(intervalId);
        intervalId = setInterval(fetchAndRenderMetrics, refreshIntervalMs);
      }

      intervalInput.addEventListener('change', () => {
        const value = Number(intervalInput.value);
        if (!Number.isFinite(value) || value < 5) {
          intervalInput.value = '5';
          refreshIntervalMs = 5000;
        } else {
          refreshIntervalMs = value * 1000;
        }
        if (toggleAutoBtn.dataset.paused !== 'true') {
          startAutoRefresh();
        }
      });

      refreshNowBtn.addEventListener('click', () => {
        fetchAndRenderMetrics();
      });

      toggleAutoBtn.addEventListener('click', () => {
        if (toggleAutoBtn.dataset.paused === 'true') {
          toggleAutoBtn.dataset.paused = 'false';
          toggleAutoBtn.textContent = 'Pause auto';
          startAutoRefresh();
        } else {
          toggleAutoBtn.dataset.paused = 'true';
          toggleAutoBtn.textContent = 'Resume auto';
          if (intervalId) clearInterval(intervalId);
        }
      });

      expandAllBtn.addEventListener('click', () => {
        const sections = metricsContainer.querySelectorAll('.category-section');
        sections.forEach((section) => {
          const content = section.querySelector('.category-content');
          const toggle = section.querySelector('.category-toggle');
          content.classList.remove('collapsed');
          toggle.textContent = '▼';
        });
      });

      collapseAllBtn.addEventListener('click', () => {
        const sections = metricsContainer.querySelectorAll('.category-section');
        sections.forEach((section) => {
          const content = section.querySelector('.category-content');
          const toggle = section.querySelector('.category-toggle');
          content.classList.add('collapsed');
          toggle.textContent = '▶';
        });
      });

      async function fetchPostVariables() {
        try {
          const res = await fetch('/api/post-variables');
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          postVariables = Array.isArray(data.variables) ? data.variables : [];
        } catch (err) {
          console.error('Failed to load POST variables', err);
          postVariables = [];
        }
      }

      // Initial load: load POST variable list first so controls can attach, then start metrics
      (async () => {
        await fetchPostVariables();
        await fetchAndRenderMetrics();
        startAutoRefresh();
      })();
    </script>
  </body>
  </html>